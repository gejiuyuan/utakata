!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).utakata=e.utakata||{})}(this,(function(e){"use strict";function t(e){return"function"==typeof e}const n=Object.create(null);function c(e){return Object(e)===e}function r(e,t){return!Object.is(e,t)}const o=(()=>{const{queueMicrotask:e,Promise:t}=globalThis||window||global||self;return e?function(t){return e(t)}:function(e){return t.resolve().then(e)}})();e.activeEffect=void 0;const s=[];class f{constructor(e,t=null){this.func=e,this.schduler=t,this.func=e,this.schduler=t}run(){if(!s.includes(this))try{return s.push(e.activeEffect=this),this.func()}finally{s.pop();const{length:t}=s;e.activeEffect=t>0?s[t-1]:void 0}}}var u;e.WatcherFlush=void 0,(u=e.WatcherFlush||(e.WatcherFlush={})).async="async",u.sync="sync";const i=Object.values(e.WatcherFlush);const a=new WeakMap;function l(t,n){let c=a.get(t);c||a.set(t,c=new Map);let r=c.get(n);r?r.add(e.activeEffect):c.set(n,r=new Set([e.activeEffect]))}function h(e,t,n,c){const o=a.get(e);if(!o)return;const s=o.get(t);s&&r(n,c)&&Array.from(s).forEach((e=>{var t;(null===(t=e.schduler)||void 0===t?void 0:t.call(e))||e.run()}))}const d="__reactive__",p=e=>!!c(e)&&Reflect.get(e,d);function v(){return(e,t,n)=>(l(e,t),Reflect.get(e,t))}function y(){return(e,t,n)=>{const c=Reflect.get(e,t);let o=!0;return r(n,c)&&(h(e,t,n,c),o=Reflect.set(e,t,n)),o}}e.EMPTY_OBJECT=n,e.ReactiveEffect=f,e.__REACTIVE__=d,e.createGetter=v,e.createSetter=y,e.effect=function(e,t){e.effect&&(e=e.effect.func);const n=new f(e);t&&t.lazy||n.run();const c=n.run.bind(n);return Reflect.set(c,"effect",n),c},e.effectStack=s,e.hasChanged=r,e.isFunc=t,e.isReactive=p,e.isReferenceType=c,e.nextTick=o,e.objEffectWeakMap=a,e.reactive=function(e){if(!c(e))return void console.warn("The parameter of 'reactive' must be a object!");if(p(e))return e;const t=new Proxy(e,{get:v(),set:y()});return Reflect.defineProperty(t,d,{configurable:!1,enumerable:!1,get:()=>!0}),t},e.track=l,e.trigger=h,e.watch=function(c,s,u=n){if(!t(s))return void console.error("The second parameter of 'watch' ———— 'cb' must be a function!");const{flush:a=e.WatcherFlush.async,immediate:l=!1}=u;let h={};const d=()=>{const e=v.run();r(e,h)&&(s.apply(null,[e,h]),h=e)};i.includes(a)||console.warn(`The 'flush' parameter value of 'watch' options should be one of the two options: ${i.join("、")}`);const p=a===e.WatcherFlush.async?()=>o(d):d,v=new f((()=>c()),p);l?p():h=v.run()},Object.defineProperty(e,"__esModule",{value:!0})}));
