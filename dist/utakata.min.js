!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).utakata=e.utakata||{})}(this,(function(e){"use strict";function t(e){return"function"==typeof e}const n=Object.create(null);function c(e){return Object(e)===e}function o(e,t){return!Object.is(e,t)}const r=(()=>{const{queueMicrotask:e,Promise:t}=globalThis||window||global||self;return e?function(t){return e(t)}:function(e){return t.resolve().then(e)}})();e.activeEffect=void 0;const s=[];class f{constructor(e,t=null){this.func=e,this.schduler=t,this.func=e,this.schduler=t}run(){if(!s.includes(this))try{return s.push(e.activeEffect=this),this.func()}finally{s.pop();const{length:t}=s;e.activeEffect=t>0?s[t-1]:void 0}}}var u;e.WatcherFlush=void 0,(u=e.WatcherFlush||(e.WatcherFlush={})).async="async",u.sync="sync";const i=Object.values(e.WatcherFlush),a={};const l=new WeakMap;function h(t,n){let c=l.get(t);c||l.set(t,c=new Map);let o=c.get(n);o?o.add(e.activeEffect):c.set(n,o=new Set([e.activeEffect]))}function d(e,t,n,c){const r=l.get(e);if(!r)return;const s=r.get(t);s&&o(n,c)&&Array.from(s).forEach((e=>{var t;(null===(t=e.schduler)||void 0===t?void 0:t.call(e))||e.run()}))}const p="__reactive__",v=e=>!!c(e)&&Reflect.get(e,p);function y(){return(e,t,n)=>(h(e,t),Reflect.get(e,t))}function b(){return(e,t,n)=>{const c=Reflect.get(e,t);let r=!0;return o(n,c)&&(d(e,t,n,c),r=Reflect.set(e,t,n)),r}}e.EMPTY_OBJECT=n,e.ReactiveEffect=f,e.__REACTIVE__=p,e.createGetter=y,e.createSetter=b,e.effect=function(e,t){e.effect&&(e=e.effect.func);const n=new f(e);t&&t.lazy||n.run();const c=n.run.bind(n);return Reflect.set(c,"effect",n),c},e.effectStack=s,e.hasChanged=o,e.isFunc=t,e.isReactive=v,e.isReferenceType=c,e.nextTick=r,e.objEffectWeakMap=l,e.reactive=function(e){if(!c(e))return void console.warn("The parameter of 'reactive' must be a object!");if(v(e))return e;const t=new Proxy(e,{get:y(),set:b()});return Reflect.defineProperty(t,p,{configurable:!1,enumerable:!1,get:()=>!0}),t},e.track=h,e.trigger=d,e.watch=function(c,s,u=n){if(!t(s))return void console.error("The second parameter of 'watch' ———— 'cb' must be a function!");const{flush:l=e.WatcherFlush.async,immediate:h=!1}=u;let d=a;const p=()=>{const e=y.run();o(e,d)&&(s.apply(null,[e,d===a?void 0:d]),d=e)};i.includes(l)||console.warn(`The 'flush' parameter value of 'watch' options should be one of the two options: ${i.join("、")}`);const v=l===e.WatcherFlush.async?()=>r(p):p,y=new f((()=>c()),v);h?v():d=y.run()},Object.defineProperty(e,"__esModule",{value:!0})}));
