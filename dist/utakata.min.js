!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).utakata=e.utakata||{})}(this,(function(e){"use strict";function t(e){return"function"==typeof e}const n=Object.create(null);function c(e){return Object(e)===e}function r(e,t){return!Object.is(e,t)}const o=(()=>{const{queueMicrotask:e,Promise:t}=globalThis||window||global||self;return e?function(t){return e(t)}:function(e){return t.resolve().then(e)}})();e.activeEffect=void 0;const a=[];class f{constructor(e,t=null){this.func=e,this.schduler=t,this.deps=[]}static cleanUpEffect(e){const{deps:t}=e;t.forEach((t=>{t.delete(e)})),t.length=0}run(){if(!a.includes(this))try{return a.push(e.activeEffect=this),this.func()}finally{a.pop();const{length:t}=a;e.activeEffect=t>0?a[t-1]:void 0}}stop(){f.cleanUpEffect(this)}}var i;e.WatcherFlush=void 0,(i=e.WatcherFlush||(e.WatcherFlush={})).async="async",i.sync="sync";const s=Object.values(e.WatcherFlush),u={};const l=new WeakMap;let h=!0;function d(){return!h&&void 0===e.activeEffect}function v(t,n){if(d())return;let c=l.get(t);c||l.set(t,c=new Map);let r=c.get(n);r||c.set(n,r=new Set([e.activeEffect])),p(r)}function p(t){h=!t.has(e.activeEffect),h&&(t.add(e.activeEffect),e.activeEffect.deps.push(t))}function g(e,t,n,c){const o=l.get(e);if(!o)return;const a=o.get(t);a&&r(n,c)&&Array.from(a).forEach((e=>{var t;(null===(t=e.schduler)||void 0===t?void 0:t.call(e))||e.run()}))}e.ReactiveTargetMarker=void 0,(e.ReactiveTargetMarker||(e.ReactiveTargetMarker={})).__REACTIVE__="__reactive__";const E=new WeakMap;function y(t){if(!c(t))return void console.warn("The parameter of 'reactive' must be a object!");const n=E.get(t);if(n)return n;const r=new Proxy(t,{get:T(),set:b()});return Reflect.defineProperty(r,e.ReactiveTargetMarker.__REACTIVE__,{configurable:!0,enumerable:!1,get:()=>!0}),E.set(t,r),r}function T(){return function(e,t,n){const r=Reflect.get(e,t);return v(e,t),c(r)?y(r):r}}function b(){return function(e,t,n){const c=Reflect.get(e,t);let o=!0;return r(n,c)&&(o=Reflect.set(e,t,n),g(e,t,n,c)),o}}e.EMPTY_OBJECT=n,e.ReactiveEffect=f,e.createGetter=T,e.createSetter=b,e.effect=function(e,t){e.effect&&(e=e.effect.func);const n=new f(e);t&&t.lazy||n.run();const c=n.run.bind(n);return Reflect.set(c,"effect",n),c},e.effectStack=a,e.hasChanged=r,e.isFunc=t,e.isPauseTracking=d,e.isReactive=t=>!!c(t)&&Reflect.get(t,e.ReactiveTargetMarker.__REACTIVE__),e.isReferenceType=c,e.nextTick=o,e.objEffectWeakMap=l,e.reactive=y,e.reactiveTargetMap=E,e.track=v,e.trackEffect=p,e.trigger=g,e.watch=function(c,a,i=n){if(!t(a))return void console.error("The second parameter of 'watch' ———— 'cb' must be a function!");const{flush:l=e.WatcherFlush.async,immediate:h=!1}=i;let d=u;const v=()=>{const e=g.run();r(e,d)&&(a.apply(null,[e,d===u?void 0:d]),d=e)};s.includes(l)||console.warn(`The 'flush' parameter value of 'watch' options should be one of the two options: ${s.join("、")}`);const p=l===e.WatcherFlush.async?()=>o(v):v,g=new f((()=>c()),p);return h?p():d=g.run(),()=>{g.stop()}},Object.defineProperty(e,"__esModule",{value:!0})}));
